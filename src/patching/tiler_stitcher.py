import numpy as np
import skimage.util as util
from typing import Tuple

from .viz_patches import viz_patches


class TilerStitcher:
    def __init__(
            self,
            im_shape: Tuple[int],
            patch_shape: Tuple[int],
            stride_size: int,
            padding: bool=True
        ) -> None:
        """
        Patch extractor and stitcher class.
        Operates on numpy arrays

        Args:
        -------------
            im_shape (Tuple[int]):
                input image shape (H, W, C)
            patch_shape (Tuple[int]):
                Shape of a patch (H, W) | (H, W, C).
            stride_size (int):
                Stride of the sliding window
            padding (bool):
                pad the input image to a multiple of patch_shape such 
                that every part of input gets patched. Creates some 
                redundancy.
        """
        assert 1 <= len(patch_shape) <= 3, (
            "Too many patch dims. Use (H, W) or (H, W, C)"
        )
        self.ih, self.iw = im_shape[:2]
        self.ph, self.pw = patch_shape[:2]
        self.stride_size = stride_size
        self.padding = padding
        self.ntile_x = self.ntile_y = None
        self.C = im_shape[-1] if len(im_shape) == 3 else 1

    @property
    def margins(self) -> Tuple[int]:
        """
        Returns:
        ------------
            Tuple[int]. Length of margins needed in the input image. 
            Multiple of patch_shape
        """
        extra_pad = 200
        margin_y = int(
            np.ceil((self.ih + extra_pad) / self.ph)*self.ph - self.ih
        )
        margin_x = int(
            np.ceil((self.iw + extra_pad) / self.pw)*self.pw - self.iw
        )
        return margin_y, margin_x

    def extract_patches_quick(self, im: np.ndarray) -> np.ndarray:
        """
        Use numpy stride tricks via skimage to patch the image.

        Args:
        -------------
            im (np.ndarray):
                Input image. Shape (H, W, C) | (H, W)

        Returns:
        -------------
            np.ndarray: patched image of shape 
            (n_patches, patch_height, patch_width, C)
        """
        if len(im.shape) == 2:
            im = im[..., None]

        if self.padding:
            pad_y, pad_x = self.margins
            im = np.pad(
                im, 
                [(pad_y, pad_y),(pad_x, pad_x), (0, 0)], 
                mode="reflect"
            )
        
        patches = util.view_as_windows(
            im, 
            (self.ph, self.pw, self.C),
            self.stride_size
        )
        self.ntile_y = patches.shape[0]
        self.ntile_x = patches.shape[1]
        patches = patches.reshape(-1, self.ph, self.pw, self.C)

        return patches.squeeze()

    
    def stitch_patches(self, patches: np.ndarray) -> np.ndarray:
        """
        Stitch patches back to one image.
        Patches need to be generated by the same instances 
        extract_patches_quick() method

        Args:
        ------------
            patches (np.ndarray):
                input image in patches of shape (n_patches, H, W, C).

        Returns:
        ------------
            np.ndarray (image) of shape (H, W, C) 
        """
        assert self.ntile_x != None, (
            "Stitching patches has to be done with the same",
            "TilerStitcher instance as patch extracting"
        )

        if len(patches.shape) == 3:
            patches = patches[..., None]

        n_channels = patches.shape[-1]
        pad = self.stride_size
        patches = patches.reshape(
            self.ntile_y, self.ntile_x, self.ph, self.pw, n_channels
        )
        patches = patches[:, :, 0:pad, 0:pad, :]
        im = np.concatenate(np.concatenate(patches, 1), 1)

        if self.padding:
            pad_x, pad_y = self.margins
            im = im[pad_x:self.ih+pad_x, pad_y:self.iw+pad_y, :]

        return im.squeeze()

    @staticmethod
    def vizualize(patches: np.ndarray) -> Tuple[int]:
        viz_patches(patches)