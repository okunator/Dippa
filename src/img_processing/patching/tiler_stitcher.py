import numpy as np
import skimage.util as util
from typing import Tuple


# TODO: cv2 copymakeborer padding + image boundary weighting
class TilerStitcher:

    def __init__(self,
                 im_shape: Tuple[int],
                 patch_shape: Tuple[int],
                 stride_size: int,
                 padding: bool=True) -> None:
        """
        Patch extractor and stitcher class

        Args:
            im_shape (Tuple[int]):
                input image shape (H, W, C)
            patch_shape (Tuple[int]):
                Shape of a patch (H, W) | (H, W, C).
            stride_size (int):
                Stride of the sliding window
            padding (bool):
                pad the input image to a multiple of patch_shape such that 
                every part of input gets patched. Creates some redundancy.
        """
        assert 1 <= len(patch_shape) <= 3, "Too many patch dims. Use (H, W) or (H, W, C)"
        self.ih, self.iw = im_shape[:2]
        self.ph, self.pw = patch_shape[:2]
        self.stride_size = stride_size
        self.padding = padding
        self.ntile_x = self.ntile_y = None
        self.C = im_shape[-1] if len(im_shape) == 3 else 1

    @property
    def margins(self) -> Tuple[int]:
        """
        Returns:
            Tuple[int]. Length of margins needed in the input image. Multiple of patch_shape
        """
        extra_pad = 200
        margin_y = int(np.ceil((self.ih + extra_pad) / self.ph)*self.ph - self.ih)
        margin_x = int(np.ceil((self.iw + extra_pad) / self.pw)*self.pw - self.iw)
        return margin_y, margin_x

    def extract_patches_quick(self, im: np.ndarray, n_channels: int=3) -> np.ndarray:
        """
        Use numpy stride tricks via skimage to patch the image quickly.

        Args:
            im (np.ndarray):
                Input image. Shape (H, W, C) | (H, W)
                
        Returns:
            patched image of shape (n_patches, patch_height, patch_width, C)
        """
        if len(im.shape) == 2:
            im = im[..., None]

        if self.padding:
            pad_y, pad_x = self.margins
            im = np.pad(im, [(0, pad_y), (0, pad_x), (0, 0)], mode="reflect")
        
        patches = util.view_as_windows(im, (self.ph, self.pw, self.C), self.stride_size)
        self.ntile_y = patches.shape[0]
        self.ntile_x = patches.shape[1]
        patches = patches.reshape(-1, self.ph, self.pw, self.C)

        return patches.squeeze()

    
    def stitch_patches(self, patches: np.ndarray, n_channels: int=3) -> np.ndarray:
        """
        Stitch patches (generated by extract_patches_quick) back to one image.

        Args:
            patches (np.ndarray):
                input image in patches of shape (n_patches, H, W, C).
            n_channels (int, default=3):
                Number of channels in the output. 

        Returns:
            np.ndarray (image) of shape (H, W, C) 
        """
        assert self.ntile_x != None

        if len(patches.shape) == 3:
            patches = patches[..., None]

        patches = patches.reshape(self.ntile_y, self.ntile_x, self.ph, self.pw, n_channels)
        patches = patches[:, :, 0:self.stride_size, 0:self.stride_size, :]
        im = np.concatenate(np.concatenate(patches, 1), 1)

        if self.padding:
            im = im[0:self.ih, 0:self.iw, :]

        return im.squeeze()